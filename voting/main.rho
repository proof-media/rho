
new closedVoteFlag, votersSet, votesMapStore,
  log(`rho:io:stdout`) in
{

  log!("Deploying main Proof Voting contracts  ^_^/  ") |

  //////////////////////
  // INIT

  // List of identifiers for users accepted for voting
  votersSet!!(
    Set("user001", "user002", "user003")
  )
  |
  // Storing votes in this HashMap
  votesMapStore!({})
  |
  // Flag used to check if vote is still open
  closedVoteFlag!(false) // accepting votes at startup
  |

  //////////////////////
  // CONTRACTs

  // Contract called to set the status and block voting
  contract @["Proof", "TallyVote"](_) = {
    log!("Tallying the vote") |
    closedVoteFlag!(true)
  } |

  // Contract that receives votes and check:
  // - if voting is closed (when TallyVote is called)
  // - if vote is valid (meaning from a valid/accepted user)
  // - if they is a double vote (same valid users tried to vote more than once)
  contract @["Proof", "CastVote"](@userId, @vote, ack) = {

    for (@isClosed <- closedVoteFlag) {

      closedVoteFlag!(isClosed) |

      // WHEN VOTE IS CLOSE
      if (isClosed) {
        log!("x NOT accepting votes anymore: " ++ userId)

        |
        // Contract to send results/'proofs' back
        // but only if voting is closed
        contract @["Proof", "VoteResults"](sendResults) = {
          // NOTE: if this part of the code is not inside
          // this nested part of the main contract
          // it would print empty HashMap
          for (@isClosed <- closedVoteFlag) {
            closedVoteFlag!(isClosed) |
            if (isClosed) {
              for (@voteMap <- votesMapStore) {
                votesMapStore!(voteMap) |
                sendResults!(voteMap)
              }
            } else{
              log!("vote still open")
            }
          }
        }

      // WHEN VOTE IS OPEN
      } else{

        log!("-> request: " ++ userId) |
        for (@voter <- votersSet)
        {
          if (voter.contains(userId)) {
            for (@voteMap <- votesMapStore)
            {
              if (voteMap.contains(userId)) {
                votesMapStore!(voteMap) |
                log!("<- " ++ userId ++ " already voted")
              } else {
                log!("<- " ++ userId ++ " valid (" ++ vote ++ ")") |
                votesMapStore!(voteMap.set(userId, vote)) |
                ack!(userId ++ " ack")
              }
            }
          } else {
            log!("<- " ++ userId ++ " invalid")
          }

        }
      }
    }
  }

}
